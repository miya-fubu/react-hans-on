# ES2015以降のJS

1章ではJSの基本的な文法について簡単に説明しました。

ですが、はっきり言って1章で説明した内容は現在は使われていません。

`var`で変数を宣言する人はいませんし、理由がない限りは`function`で関数は書きません。
for文も、`for`はほぼ見ませんし、`for in`なんて理由がなければまず使わないです。

本稿では、比較的今どきのJS である ES2015 対応のJSについて話してゆきます。

## ECMAScriptについて

先ほど挙げたES2015というのは、ECMAScript 2015 (あるいはECMAScript 6)のことを指します。

これは、2015年にリリースされたJavaScriptの標準仕様第6版のことです。
これまでに説明したJSは、ECMAScript 5という仕様に当たります。

この ECMAScript 2015 ではJSの持つバグの温床となる部分を避けるべく、数多くの書き方が新たに追加されました。そして、これらがあまりにも便利であるために、現在ではES2015に合わせた書き方で書くことができる箇所に関しては、旧前のJSは使われなくなっています。

## よく使われるES2015の文法

### 変数の宣言

ES2015では今までの`var`の代わりに`const`,`let`の2つが新しく追加されました。
それぞれ、再代入ができない宣言方法、再代入ができる宣言方法となります。

再代入と言われてもピンとこないと思うので、例文を用意しました。

```js
const foo = 'foo'
let bar = 'bar'

foo = 'bar'
# >> Uncaught TypeError: Assignment to constant variable.
bar = 'foo'
```

再代入ができないとはこういうことです。
一度constで宣言した変数は、=を使用して新たな値を入れることができません。

最初に宣言した値の中身が、後の方に登場しても変化していないことを保証してくれる、という状況がどれほどコーディングの際に優位かは述べる必要もないでしょう。

**特に理由がなければ、変数の宣言はconstで行うべきです**

なお、注意点として、constは**中の値が宣言時と同じであることを保証はしていません**。例えば、以下のような場合は問題なくコードが通ります。

```js
const foo = {}
foo.bar = 1
console.log(foo)
# >> { bar: 1 }
```

他にも、配列であれば配列操作などで値を書き換えることができます。
あくまで、再代入が行えない(≒型が変わっていない)というだけであるということに注意してください。

### アロー関数

functionの項では割愛しましたが、JSの関数にはThisと呼ばれるものがあります。これは非常に便利なのですが、Thisが何を参照しているかがわかりにくいために、バグの温床となっていました。
これを解決しつつ、コードの記載量を減らすことが可能な関数としてアロー関数というものがあります。

具体的には、こういった書き方をします。

```js
function foo (text){
  return 'foo'+text
}

# ↓

const foo = text => 'foo'+text

# or

const foo = (text) => {
  return 'foo'+text
}
```

見ての通り、アロー関数は無名関数です。名前を付けたい場合は、無名関数を変数に入れるという使い方をします。
また、特徴として、省略記法が多いということが挙げられます。

- ワンライナーの場合は`{}`を省略できる
- 引数が一つであれば引数を囲う括弧も省略できる

そして、functionのThisとは異なり、アロー関数で定義されているスコープに基づいてThisが定義されます。便利ですね。

ただ、便利ですがThisの振る舞いについて覚える必要はありません。Thisを使用することはつまり純粋でない関数を作成するということなので、Thisは使用しない関数を作るべきです。

現在では、特殊な理由がない限りアロー関数を使いましょう。

### デストラクチャリング

非常によく使う機能です。
デストラクチャリングとは、オブジェクトを受け取る際に必要なプロパティ以外を切り捨てる機能です。膨大なデータからデータを取捨選別したり、関数の引数をオブジェクトで取得する際に宣言を行う手間を省くために使われたりすることが多いです。

例としては、こんなものがあります。

```js
const foo = { f: 1, o: 2 }
const print = ({ f, o }) => {
  console.log(f + o)
}
console.log(print(foo))
# >> 3

const { b } = { b: 'b', a: 'a', r: 'r'}
console.log(b)
# >> b
console.log(a)
# >> Uncaught ReferenceError: a is not defined
```

また、配列でも使用できます。

```js
const [foo, bar] = [1, 2]
console.log(foo)
# >> 1
console.log(bar)
# >> 2
```

### デフォルト引数

Pythonのように関数の引数としてデフォルト引数を設定できます。

```js
const foo = (arg = 'default') => {
  console.log(arg)
}
foo()
# >> default
```

### 三項演算子

単純なif文を一行にまとめる機能です。
`boolean値を返す式 ? trueの場合の値 : falseの場合の値`と記載します。

```js
const zero = 0
console.log(zero ? 'foo' : 'bar')
# >> 'bar'
```

なお、いくつもの三項演算子をつなげることも可能ですが、複数つなげることは可読性の低下を招くので、原則なし、多くても2つにしましょう。

### スプレッド構文

非常によく使う機能です。
配列やオブジェクトを、要素ごとに分割します。
配列のコピーやオブジェクトを分解して引数に渡す際によく使用します。

```js
const a = []
const b = a
# pushは配列の末尾に値を投入するメソッドです。
a.push(1)
console.log(a)
# >> [1]
console.log(b)
# >> [1]

const c = [...a]
a.push(2)
console.log(a)
# >> [1,2]
console.log(c)
# >> [1]
```

なお、この操作でコピーした場合は当然ディープコピーではないということに注意してください。

### テンプレートリテラル

テキストに変数を加えるという操作を、より可読性の高い形で実装できます。

```
const foo = 'foo'
console.log('result: ' + foo)
console.log(`result: ${foo}`)
```

### for of

`for in`の際に、indexではなく値が欲しいと思ったかと思います。
`for of`は、その値を返すfor文です。

```js
const sumList = [1,2,3]
let count = 0

for(index in sumList){
  count += sumList[index]
}
for(value of sumList){
  count -= value
}
console.log(count)
# >> 0
```

### 非同期処理 (Promise)

JSと言えば非同期処理。
昔の非同期処理は非常に使いにくかったですが、ES2015にて追加された`Promise`にて多少使いやすくなりました。

Promiseの存在を簡単に説明すると、処理を実行したら結果が返ってくるまで仮の値としてpromiseオブジェクトを返しておき、値が返ってきたらpromiseオブジェクトから帰ってきた結果の値を渡す、という処理を行ってくれる存在です。

こちらに関しては簡単に解説するということが難しいため、以下のリンクを参照してください。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise

現在では、ES2017にてリリースされたasync/awaitを主に使いつつ、Promiseを使わざるを得ないところではPromiseを使用するというのが主です。

### import文

1章で説明したrequireを使用したモジュールのインポートですが、実は現在のブラウザではこちらは動作しません。
現在では、import文と呼ばれる新しい書き方でモジュールのインポートを行います。

```
const foo = require(./foo.js)
import foo from './foo.js'
```

ちなみに、エクスポート側の書き方も変わっています。

```
module.exports = foo;
default export foo;
```

なお、Node.jsではimport文をサポートしていません。


## babelについて

ES2015は非常に便利な書き方が多く含まれた仕様ですが、一点問題がありました。

IEの存在です。

困ったことに、IEはES2015をサポートしておらず、使用できない機能が多数存在しました。
そこで登場したのが、古いブラウザにも使えるように今どきのJSを変換(トランスコンパイル)するツール、babelです。

IEがあまり使われなくなった今でも、次世代の仕様を反映していないブラウザでも次世代の仕様で書いたコードが動作するように変換することを目的に、babelは使われ続けています。(ES2021標準のコードを、ES2015標準にトランスコンパイルする、など)
